/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/client/js/installer.js":
/*!************************************!*\
  !*** ./src/client/js/installer.js ***!
  \************************************/
/***/ (() => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Shape = /*#__PURE__*/_createClass(function Shape(sx, sy, ex, ey) {\n  _classCallCheck(this, Shape);\n\n  this.sx = sx;\n  this.sy = sy;\n  this.ex = ex;\n  this.ey = ey;\n});\n\nvar Square = /*#__PURE__*/function (_Shape) {\n  _inherits(Square, _Shape);\n\n  var _super = _createSuper(Square);\n\n  function Square() {\n    var _this;\n\n    _classCallCheck(this, Square);\n\n    _this = _super.call(this, sx, sy, ex, ey);\n    _this.name = \"square \".concat(square.length + 1);\n    return _this;\n  }\n\n  return _createClass(Square);\n}(Shape);\n\nvar Circle = /*#__PURE__*/function (_Shape2) {\n  _inherits(Circle, _Shape2);\n\n  var _super2 = _createSuper(Circle);\n\n  function Circle() {\n    var _this2;\n\n    _classCallCheck(this, Circle);\n\n    _this2 = _super2.call(this, sx, sy, ex, ey);\n    _this2.name = \"circle \".concat(circle.length + 1);\n    return _this2;\n  }\n\n  return _createClass(Circle);\n}(Shape);\n\nvar sx, sy, ex, ey;\nvar square = [];\nvar circle = [];\nvar paints = [];\nvar moving = -1;\nvar sq, cr;\nvar squarePating = false;\nvar circlePating = false;\nvar squareKey = \"square\";\nvar circleKey = \"circle\";\nvar canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nvar squareBtn = document.querySelector(\".js-square\");\nvar circleBtn = document.querySelector(\".js-circle\");\nvar range = document.querySelector(\".js-range\");\nvar restoreBtn = document.querySelector(\".js-restore\");\nvar saveBtn = document.querySelector(\".save_btn\");\n\nvar handleRestoreBtnClick = function handleRestoreBtnClick() {\n  var check = paints.pop();\n  var base = check.name.substring(0, 6);\n\n  if (base === \"square\") {\n    square.pop();\n    savePaint();\n  }\n\n  if (base === \"circle\") {\n    circle.pop();\n    savePaint();\n  }\n\n  drawPating();\n};\n\nvar handleSaveBtnClick = function handleSaveBtnClick() {\n  var user = canvas.dataset.user;\n  var image = canvas.toDataURL();\n  var a = document.createElement(\"a\");\n  a.href = image;\n  fetch(\"/api/interior/\".concat(user, \"/save\"), {\n    method: \"POST\",\n    body: {\n      a: a\n    }\n  });\n};\n\nvar savePaint = function savePaint() {\n  localStorage.setItem(squareKey, JSON.stringify(square));\n  localStorage.setItem(circleKey, JSON.stringify(circle));\n};\n\nvar handleSquareBtnClick = function handleSquareBtnClick() {\n  if (sq === true) {\n    sq = false;\n    squareBtn.innerText = \"사각형\";\n  } else {\n    sq = true;\n    cr = false;\n    squareBtn.innerText = \"사각형 사용중\";\n  }\n};\n\nvar getSquareTarget = function getSquareTarget(x, y) {\n  for (var i = 0; i < square.length; i++) {\n    var s = square[i];\n\n    if (x > s.sx && x < s.ex && y > s.sy && y < s.ey) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nvar drawPating = function drawPating() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  for (var i = 0; i < square.length; i++) {\n    var rect = square[i];\n    ctx.strokeRect(rect.sx, rect.sy, rect.ex - rect.sx, rect.ey - rect.sy);\n  }\n};\n\nvar handleMousedown = function handleMousedown(e) {\n  var offsetX = e.offsetX,\n      offsetY = e.offsetY;\n  sx = offsetX;\n  sy = offsetY;\n\n  if (sq) {\n    moving = getSquareTarget(sx, sy);\n\n    if (moving === -1) {\n      squarePating = true;\n    }\n  }\n};\n\nvar handleMouseMove = function handleMouseMove(e) {\n  var offsetX = e.offsetX,\n      offsetY = e.offsetY;\n  ex = offsetX;\n  ey = offsetY;\n\n  if (squarePating) {\n    drawPating();\n    ctx.strokeRect(sx, sy, ex - sx, ey - sy);\n  } else {\n    if (moving != -1) {\n      var rect = square[moving];\n      var gapX = ex - sx;\n      var gapY = ey - sy;\n      rect.sx += gapX;\n      rect.sy += gapY;\n      rect.ex += gapX;\n      rect.ey += gapY;\n      sx = ex;\n      sy = ey;\n      savePaint();\n      drawPating();\n    }\n  } //   if (circlePating) {\n  //     drawPating();\n  //     ctx.beginPath();\n  //   }\n\n};\n\nvar handleMouseUp = function handleMouseUp() {\n  if (squarePating) {\n    var x1 = Math.min(sx, ex);\n    var y1 = Math.min(sy, ey);\n    var x2 = Math.max(sx, ex);\n    var y2 = Math.max(sy, ey);\n    var newRect = new Square(x1, y1, x2, y2);\n    square.push(newRect);\n    paints.push(newRect);\n    savePaint();\n  }\n\n  squarePating = false;\n  moving = -1;\n};\n\nvar loadPaint = function loadPaint() {\n  var squareData = localStorage.getItem(squareKey);\n\n  if (squareData !== null) {\n    var squareObj = JSON.parse(squareData);\n    square = squareObj;\n    paints = squareObj;\n    drawPating();\n  }\n};\n\nfunction init() {\n  var CANVAS_SIZE = 1000;\n  ctx.fillStyle = \"white\";\n\n  if (canvas) {\n    canvas.width = CANVAS_SIZE;\n    canvas.height = CANVAS_SIZE;\n    canvas.addEventListener(\"mousedown\", handleMousedown);\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\n    canvas.addEventListener(\"mouseup\", handleMouseUp);\n  }\n\n  if (squareBtn) {\n    squareBtn.addEventListener(\"click\", handleSquareBtnClick);\n  } //   if (circleBtn) {\n  //     circleBtn.addEventListener(\"click\", handleCircleBtnClick);\n  //   }\n\n\n  if (restoreBtn) {\n    restoreBtn.addEventListener(\"click\", handleRestoreBtnClick);\n  }\n\n  if (saveBtn) {\n    saveBtn.addEventListener(\"click\", handleSaveBtnClick);\n  }\n\n  loadPaint();\n}\n\ninit();\n\n//# sourceURL=webpack://installer/./src/client/js/installer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/client/js/installer.js"]();
/******/ 	
/******/ })()
;